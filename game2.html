<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Playing The 'Port - Level 2</title>
<style>
html, body {
  margin: 0; padding: 0;
  width: 100%; height: 100%;
  overflow: hidden;
  background: #0c0c0c;
  font-family: sans-serif;
}

header {
    position: fixed;
    text-align: left;
    border-radius: 0 0 40px 40px;
    background-color: rgb(180, 114, 255);
    right: -9vw;
    top: -0.1vw;
    margin: 0;
    padding: 0;
    z-index: 1000;
}

header.firstpage {
    position: fixed;
    text-align: left;
    margin: 0;
    height: 3vw;
    padding-left: 1vw;
    padding-right: 10vw;
    padding-top: 0.8vw;
    padding-bottom: 0.8vw;
    z-index: 4000;
    align-content: center;
}

header img {
    height: 1vw;
    width: auto;
    filter: invert(100%);
    padding: 0 0 0 1vw;
    transition: all 0.3s;
}

/* Container for images and outlines */
#container {
  position: absolute;
  top: 0; left: 0; 
  width: 100vw; 
  height: 100vh;
  overflow: hidden;
  background: #0e0e0e;
}

/* Draggable images */
.draggable {
  position: absolute;
  cursor: grab;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  max-width: 15vw;
  min-width: 100px;
  min-height: 70px;
  border-radius: 5px;
}
.draggable img {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 10px;
}
.draggable.dragging {
  transform: scale(1.1);
  box-shadow: 0 10px 20px rgba(0,0,0,0.5);
}

/* Outlines */
.outline {
  position: absolute;
  width: 18vw;
  min-width: 100px;
  min-height: 70px;
  height: 12vw;
  box-sizing: border-box;
  transition: border 0.3s ease;
  color: #b4b4b4;
  border-radius: 10px;
  font-weight: 300;
  font-size: clamp(12px, 1.1vw, 30px); /* Ensures a min size of 16px and max of 24px */
  padding: 1.6vw;
}

#outline1.correct {
  border: 2px solid #61a8ffdf;
  background-color: #61a8ff3b;
  border-radius: 30px;
  color: #b4b4b400;

}

#outline1 {
    border: 1px dashed #61a8ffdf;
}

#outline2.correct {
    border: 2px solid #bd97ffdf;
    background-color: #bd97ff35;
    border-radius: 30px;
    color: #b4b4b400;

}

#outline2 {
    border: 1px dashed #bd97ffdf;
}

#outline3.correct {
    border: 2px solid #f461ffdf;
    background-color: #f461ff3c;
    border-radius: 30px;
    color: #b4b4b400;

}

#outline3 {
    border: 1px dashed #f461ffdf;
}

#outline4.correct {
    border: 2px solid #61a8ffdf;
    background-color: #61a8ff33;
    border-radius: 30px;
    color: #b4b4b400;

}

#outline4 {
    border: 1px dashed #61a8ffdf;
}

#outline5.correct {
    border: 2px solid #e3e3e3df;
    background-color: #e3e3e32a;
    border-radius: 30px;
    color: #b4b4b400;

}

#outline5 {
    border: 1px dashed #e3e3e3df;
}

/* Scoreboard and Timer remain hidden */
#scoreboard {
  display: none;
}
#timer {
  display: none;
}

/* Restart button */
#restartBtn {
  position: fixed;
  top: 1em;
  left: 1em;
  background: #b472ff;
  color: #111;
  padding: 0.5em 1em;
  border: none;
  cursor: pointer;
  font-weight: 600;
  border-radius: 10px;
  z-index: 10000;
}
#restartBtn:hover {
  background: #a35cf8;
}

/* Instructions and Success overlays */
#gameInstructionOverlay,
#successOverlay {
  position: fixed;
  top:0; left:0; width:100%; height:100%;
  background: rgba(0,0,0,0.7);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
.instruction-content {
  background: #1f1f1f;
  color: #eee;
  padding: 2rem;
  max-width: 600px;
  text-align: center;
  border-radius: 20px;
}
.instruction-content h2 {
  margin-top: 0;
}

.instruction-content button {
  margin-top: 1em;
  padding: 0.7em 1.2em;
  background: #b472ff;
  color: #111;
  border: none;
  border-radius: 20px;
  cursor: pointer;
  font-weight: 600;
}
.instruction-content button:hover {
  background: #a35cf8;
}

#gameInstructionOverlay { display: flex; }

/* Reduce sizes on smaller screens */
@media (max-width: 600px) {
  .draggable {
    max-width: 130px;
    max-height: 70px;
    margin-top: -5px;
  }
  .outline {
    width: 160px;
    height: 120px;
  }
  .popup {
    width: 60vw !important;
  }
  .instruction-content p {
    line-height: 5vw !important;
  }

  header.firstpage {
        height: auto;
        padding: 2vw;
        right: 0;
        top: 0;
        border-radius: 0;
    }

    header img {
        height: 3vw; 
        width: auto;
    }
}
</style>
</head>
<body>

<button id="restartBtn">Restart</button>

<header tabindex="0" aria-label="Home Button" class="firstpage">
  <a href="index.html" style="display: inline-block; cursor: pointer;">
      <img src="img/logo.png" alt="Logo">
  </a>
</header>

<!-- Hidden scoreboard and timer -->
<div id="timer">Time: <span id="timerValue">0</span>s</div>
<div id="scoreboard">Score: <span id="scoreValue">0</span></div>

<div id="gameInstructionOverlay">
  <div class="instruction-content">
    <h2>Level 2</h2>
    <p style="line-height: 1.5vw;"><span style="color:#b472ff; font-weight: 800;">Drag</span> each image into its<br> matching <span style="color:#b472ff; font-weight: 800;">description</span> to win.</p>
    <button id="closeGameInstructionBtn">Got it!</button>
  </div>
</div>

<div id="container"></div>

<!-- Success Pop-up -->
<div id="successPopup" class="popup">
  <p id="popupMessage"></p>
</div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const container = document.getElementById('container');
    const scoreValueElem = document.getElementById('scoreValue');
    const gameInstructionOverlay = document.getElementById('gameInstructionOverlay');
    const closeGameInstructionBtn = document.getElementById('closeGameInstructionBtn');
    const timerValueElem = document.getElementById('timerValue');
    const restartBtn = document.getElementById('restartBtn');
    
    // Pop-up Elements
    const successPopup = document.getElementById('successPopup');
    const popupMessage = document.getElementById('popupMessage');
    let popupTimeout = null; // To keep track of the current timeout
  
    let gameModeActive = false;
    let score = 0;
    let timer = 0;
    let timerInterval = null;
  
    // Define sizes based on screen width for placing elements
    let outlineW = 300;
    let outlineH = 200;
    let imageW = 270;
    let imageH = 170;
  
    // Detect if the device is mobile
    const isMobile = window.innerWidth < 600;
    const allowOverlap = isMobile; // Allow overlaps on mobile as per original code
  
    if (isMobile) {
      // Smaller sizes for mobile
      outlineW = 170;
      outlineH = 110;
      imageW = 150;
      imageH = 100;
    }
  
    // Define puzzle pairs with associated messages
    const puzzlePairs = [
      { 
        imgSrc: 'img/Final-render-New-Flag-2draft-2.png', 
        imgId: 'img1', 
        outlineId: 'outline1',
        message: "I wave without hands, I fly without wings."
      },
      { 
        imgSrc: 'img/Portfolio-test-spread3-2.jpg', 
        imgId: 'img2', 
        outlineId: 'outline2',
        message: "Information lives inside me, I am a physical object and a digital concept."
      },
      { 
        imgSrc: 'img/Cast Of Characters.png', 
        imgId: 'img3', 
        outlineId: 'outline3',
        message: "I have four suits, but own no clothes. What am I?"
      },
      { 
        imgSrc: 'img/gallery2/BLUE2-jpeg-3.jpg', 
        imgId: 'img4', 
        outlineId: 'outline4',
        message: "I'm a leaf, but I dont live on a tree."
      },
      { 
        imgSrc: 'img/gallery2/The-Hot-Seat-3.jpg', 
        imgId: 'img5', 
        outlineId: 'outline5',
        message: "An uncomfortable perch."
      }
    ];
  
    let imageElements = [];
    let outlineElements = [];
  
    // Predefined fixed positions for mobile devices for Level 2
    const fixedPositionsMobile = {
      outlines: [
        { left: '15%', top: '30%' },
        { left: '55%', top: '10%' },
        { left: '10%', top: '65%' },
        { left: '55%', top: '45%' },
        { left: '42%', top: '80%' }
      ]
      // Note: Images will be randomly placed on all devices
    };
  
    // Function to check overlaps (used for non-mobile)
    function overlapsExisting(existing, x, y, w, h) {
      for (let e of existing) {
        if (x < e.x + e.w && x + w > e.x && y < e.y + e.h && y + h > e.y) {
          return true;
        }
      }
      return false;
    }
  
    // Function to place non-overlapping elements (used for non-mobile)
    function placeNonOverlappingElement(width, height, existingElements, containerRect) {
      if (allowOverlap) {
        // If overlapping is allowed, place the element without checking
        const randomX = Math.floor(Math.random() * (containerRect.width - width));
        const randomY = Math.floor(Math.random() * (containerRect.height - height));
        return { x: randomX, y: randomY };
      }
  
      const maxAttempts = 2000;
      for (let i = 0; i < maxAttempts; i++) {
        const randomX = Math.floor(Math.random() * (containerRect.width - width));
        const randomY = Math.floor(Math.random() * (containerRect.height - height));
        if (!overlapsExisting(existingElements, randomX, randomY, width, height)) {
          return { x: randomX, y: randomY };
        }
      }
      // If no non-overlapping position is found, allow overlapping
      const randomX = Math.floor(Math.random() * (containerRect.width - width));
      const randomY = Math.floor(Math.random() * (containerRect.height - height));
      return { x: randomX, y: randomY };
    }
  
    function placeElements() {
      container.innerHTML = '';
      imageElements = [];
      outlineElements = [];
  
      const containerRect = container.getBoundingClientRect();
      let placedOutlines = [];
      let placedImages = [];
  
      // Place outlines
      for (let i = 0; i < puzzlePairs.length; i++) {
        const pair = puzzlePairs[i];
        const outline = document.createElement('div');
        outline.classList.add('outline');
        outline.id = pair.outlineId;
  
        // Insert the message inside the outline
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('outline-message');
        messageDiv.textContent = pair.message;
        outline.appendChild(messageDiv);
  
        if (isMobile) {
          // Assign fixed positions for mobile
          const pos = fixedPositionsMobile.outlines[i];
          outline.style.left = pos.left;
          outline.style.top = pos.top;
          container.appendChild(outline);
          // No need to track placedOutlines for overlapping on mobile
        } else {
          // Assign random positions for non-mobile
          const pos = placeNonOverlappingElement(outlineW, outlineH, placedOutlines, containerRect);
          if (pos) {
            outline.style.left = pos.x + 'px';
            outline.style.top = pos.y + 'px';
            container.appendChild(outline);
            placedOutlines.push({x: pos.x, y: pos.y, w:outlineW, h:outlineH, id: pair.outlineId});
          } else {
            console.warn("Couldn't find position for outline, retrying...");
            location.reload();
            return;
          }
        }
  
        // Add 'visible' class to show the message
        outline.classList.add('visible');
  
        outlineElements.push(outline);
      }
  
      // Place images
      for (let i = 0; i < puzzlePairs.length; i++) {
        const pair = puzzlePairs[i];
        const imgWrapper = document.createElement('div');
        imgWrapper.classList.add('draggable');
        imgWrapper.id = pair.imgId;
        const img = document.createElement('img');
        img.src = pair.imgSrc;
        imgWrapper.appendChild(img);
  
        // Assign random positions for images regardless of device
        const pos = placeNonOverlappingElement(imageW, imageH, [...placedOutlines, ...placedImages], containerRect);
        if (pos) {
          imgWrapper.style.left = pos.x + 'px';
          imgWrapper.style.top = pos.y + 'px';
          container.appendChild(imgWrapper);
          placedImages.push({x: pos.x, y: pos.y, w:imageW, h:imageH});
        } else {
          console.warn("Couldn't find position for image, retrying...");
          return;
        }
  
        imageElements.push(imgWrapper);
      }
  
      setupDragging();
    }
  
    function setupDragging() {
      // Dragging functionality is already handled by event listeners below
    }
  
    let isDragging = false;
    let activeElement = null;
    let offsetX = 0;
    let offsetY = 0;
  
    function startDrag(e) {
      if (!gameModeActive) return;
      const target = (e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0].target : e.target;
      const draggable = target.closest('.draggable');
      if (draggable) {
        activeElement = draggable;
        const rect = activeElement.getBoundingClientRect();
        const clientX = (e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0].clientX : e.clientX;
        const clientY = (e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0].clientY : e.clientY;
  
        offsetX = clientX - rect.left;
        offsetY = clientY - rect.top;
        isDragging = true;
        activeElement.classList.add('dragging');
        e.preventDefault();
      }
    }
  
    function onMove(e) {
      if (isDragging && activeElement) {
        const clientX = (e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0].clientX : e.clientX;
        const clientY = (e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0].clientY : e.clientY;
        const containerRect = container.getBoundingClientRect();
  
        let newX = clientX - containerRect.left - offsetX;
        let newY = clientY - containerRect.top - offsetY;
  
        newX = Math.max(0, Math.min(containerRect.width - activeElement.offsetWidth, newX));
        newY = Math.max(0, Math.min(containerRect.height - activeElement.offsetHeight, newY));
  
        activeElement.style.left = `${newX}px`;
        activeElement.style.top = `${newY}px`;
      }
    }
  
    function endDrag() {
      if (isDragging && activeElement) {
        activeElement.classList.remove('dragging');
        checkDrop(activeElement);
        activeElement = null;
      }
      isDragging = false;
    }
  
    function checkDrop(imageElem) {
      const pair = puzzlePairs.find(p => p.imgId === imageElem.id);
      if (!pair) return;
  
      const outlineElem = document.getElementById(pair.outlineId);
      if (!outlineElem) return;
  
      const imgRect = imageElem.getBoundingClientRect();
      const outlineRect = outlineElem.getBoundingClientRect();
  
      const imgCenterX = (imgRect.left + imgRect.right) / 2;
      const imgCenterY = (imgRect.top + imgRect.bottom) / 2;
  
      if (
        imgCenterX > outlineRect.left &&
        imgCenterX < outlineRect.right &&
        imgCenterY > outlineRect.top &&
        imgCenterY < outlineRect.bottom
      ) {
        outlineElem.classList.add('correct');
        
        const containerRect = container.getBoundingClientRect();
        const outlineWidth = outlineElem.offsetWidth;
        const outlineHeight = outlineElem.offsetHeight;
        const imageWidth = imageElem.offsetWidth;
        const imageHeight = imageElem.offsetHeight;
  
        const newLeft = (outlineRect.left - containerRect.left) + (outlineWidth - imageWidth)/2;
        const newTop = (outlineRect.top - containerRect.top) + (outlineHeight - imageHeight)/2;
  
        imageElem.style.left = newLeft + 'px';
        imageElem.style.top = newTop + 'px';
  
        imageElem.style.pointerEvents = 'none';
        incrementScore();
  
        // Optional: Update the message appearance if needed
        // For example, change the background color or text style
      }
    }
  
    function incrementScore() {
      score++;
      scoreValueElem.textContent = score;
      if (score === puzzlePairs.length) {
        showSuccessOverlay();
      }
    }
  
    function startTimer() {
      timer = 0;
      timerInterval = setInterval(() => {
        timer++;
        timerValueElem.textContent = timer;
      }, 1000);
    }
  
    function showSuccessOverlay() {
      clearInterval(timerInterval);
  
      const successOverlay = document.createElement('div');
      successOverlay.id = 'successOverlay';
      successOverlay.style.display = 'flex';
  
      successOverlay.innerHTML = `
        <div class="instruction-content">
          <h2>Congratulations!</h2>
          <p>You matched the projects correctly.</p>
          <button id="playAgainBtn">Level 3</button>
          <button id="HomeBtn">Go Home</button>
        </div>
      `;
  
      document.body.appendChild(successOverlay);
  
      const playAgainBtn = document.getElementById('playAgainBtn');
      playAgainBtn.addEventListener('click', () => {
        location.href = 'game3.html'; // Navigate to Level 3
      });
  
      const HomeBtn = document.getElementById('HomeBtn');
      HomeBtn.addEventListener('click', () => {
        location.href = 'index.html'; // Navigate to Home
      });
    }
  
    function showPopup(message) {
      // If a pop-up is already visible, clear the existing timeout
      if (popupTimeout) {
        clearTimeout(popupTimeout);
      }
  
      // Set the message and show the pop-up
      popupMessage.textContent = message;
      successPopup.classList.add('show');
  
      // Hide the pop-up after 4 seconds
      popupTimeout = setTimeout(() => {
        successPopup.classList.remove('show');
        popupTimeout = null;
      }, 4000);
    }
  
    // Display the game instruction overlay on page load
    gameInstructionOverlay.style.display = 'flex';
  
    closeGameInstructionBtn.addEventListener('click', () => {
      gameInstructionOverlay.style.display = 'none';
      gameModeActive = true;
      score = 0;
      scoreValueElem.textContent = score;
      placeElements();
      startTimer();
    });
  
    restartBtn.addEventListener('click', () => {
      location.reload();
    });
  
    // Add event listeners for dragging
    document.addEventListener('mousedown', startDrag, false);
    document.addEventListener('mousemove', onMove, false);
    document.addEventListener('mouseup', endDrag, false);
  
    document.addEventListener('touchstart', startDrag, {passive: false});
    document.addEventListener('touchmove', onMove, {passive: false});
    document.addEventListener('touchend', endDrag, false);
  });
</script>

</body>
</html>
